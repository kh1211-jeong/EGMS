{% extends "base.html" %}

{% block head_extras %}
<style>
  .topology-intro {
    font-size: 13px;
    color: var(--text-muted);
    text-align: center;
    line-height: 1.7;
    margin-bottom: 12px;
  }
  .topology-intro b {
    color: #e5e7eb;
  }

  .topology-layout {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 4px;
  }

  /* 상단 검색 툴바 */
  .topology-toolbar {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 12px;
  }
  .topology-search-select,
  .topology-search-input,
  .topology-search-button {
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.6);
    background: rgba(15, 23, 42, 0.9);
    color: #e5e7eb;
    font-size: 12px;
    padding: 6px 10px;
    outline: none;
  }
  .topology-search-select {
    min-width: 90px;
  }
  .topology-search-input {
    flex: 1;
  }
  .topology-search-button {
    padding-inline: 14px;
    background: linear-gradient(to right, #38bdf8, #6366f1);
    border-color: transparent;
    cursor: pointer;
  }
  .topology-search-button:hover {
    opacity: 0.9;
  }

  /* 최근 검색 */
  .topology-recent {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 4px;
    font-size: 11px;
    color: var(--text-muted);
  }
  .topology-recent-label {
    opacity: 0.8;
    margin-right: 4px;
  }
  .topology-recent-chip {
    border-radius: 999px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    padding: 3px 8px;
    background: rgba(15, 23, 42, 0.9);
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    gap: 4px;
  }
  .topology-recent-chip-key {
    opacity: 0.7;
  }
  .topology-recent-chip-query {
    color: #e5e7eb;
  }

  /* 트리 뷰포트: 내용은 드래그로 이동, 스크롤바는 숨김 */
  .topology-graph-shell {
    border-radius: 18px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    background: radial-gradient(circle at top, rgba(15, 23, 42, 0.96), rgba(15, 23, 42, 1));
    height: 320px;
    padding: 18px 24px;
    overflow: hidden;
    position: relative;
    cursor: default;
  }

  .topology-graph {
    position: relative;
    display: inline-block;
    min-width: 100%;
    min-height: 100%;
  }

  .topology-svg {
    overflow: visible;
  }

  /* 노드/선 스타일 */
  .topology-node-circle {
    fill: #38bdf8;
    stroke: #e0f2fe;
    stroke-width: 1;
    filter: drop-shadow(0 0 6px rgba(56, 189, 248, 0.8));
  }
  .topology-node-label {
    font-size: 11px;
    fill: #e5e7eb;
  }
  .topology-edge-line {
    stroke: rgba(148, 163, 184, 0.9);
    stroke-width: 1;
  }

  /* 검색 하이라이트 */
  .topology-node--highlight .topology-node-circle {
    fill: #f97316;
    stroke: #fed7aa;
    filter: drop-shadow(0 0 8px rgba(249, 115, 22, 0.9));
  }
  .topology-node--highlight .topology-node-label {
    fill: #fed7aa;
    font-weight: 600;
  }
  .topology-edge--highlight {
    stroke: #f97316;
    stroke-width: 2;
  }

  .topology-status-text {
    font-size: 12px;
    color: var(--text-muted);
    margin-top: 4px;
  }

  /* 아래 인트로: 엑셀 표 + 스크롤바 */
  .topology-node-list {
    font-size: 11px;
    color: var(--text-muted);
    line-height: 1.7;
    max-height: 220px;
    overflow: auto;
    border-radius: 12px;
    border: 1px solid rgba(55, 65, 81, 0.9);
    padding: 8px 10px;
    background: rgba(15, 23, 42, 0.9);
  }

  .topology-node-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 4px;
  }
  .topology-node-table th,
  .topology-node-table td {
    border: 1px solid rgba(75, 85, 99, 0.9);
    padding: 4px 6px;
    font-size: 11px;
    text-align: left;
    white-space: nowrap;
  }
  .topology-node-table thead {
    background: rgba(15, 23, 42, 0.95);
    color: #e5e7eb;
  }
  .topology-node-table tbody tr:nth-child(odd) {
    background: rgba(15, 23, 42, 0.85);
  }
  .topology-node-table tbody tr:nth-child(even) {
    background: rgba(17, 24, 39, 0.95);
  }
   /* === (추가) 노드 상태별 색상 === */
  .topology-node.status-normal  .topology-node-circle { fill:#0f766e; stroke:#22c55e; }
  .topology-node.status-warn    .topology-node-circle { fill:#854d0e; stroke:#eab308; }
  .topology-node.status-fail    .topology-node-circle { fill:#7f1d1d; stroke:#ef4444; }
  .topology-node.status-unknown .topology-node-circle { fill:#111827; stroke:#4b5563; }

  /* === (추가) 마우스 오버 툴팁 === */
  .eqp-tooltip {
    position: fixed;
    min-width: 220px;
    max-width: 280px;
    padding: 10px 12px;
    font-size: 11px;
    border-radius: 10px;
    background: rgba(15,23,42,0.97);
    border: 1px solid rgba(148,163,184,0.7);
    color: #e5e7eb;
    box-shadow: 0 12px 30px rgba(15,23,42,0.9);
    pointer-events: none;
    z-index: 50;
    display: none;
  }
  .eqp-tooltip-title {
    font-size: 12px;
    font-weight: 600;
    margin-bottom: 4px;
  }
  .eqp-tooltip-sub {
    font-size: 11px;
    color: var(--text-soft);
    margin-bottom: 6px;
  }
  .eqp-tooltip-row {
    display: flex;
    justify-content: space-between;
    font-size: 11px;
  }

  /* === (추가) 클릭 팝업(모달) === */
  .eqp-modal-backdrop {
    position: fixed;
    inset: 0;
    background: rgba(15,23,42,0.75);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 60;
  }
  .eqp-modal {
    width: 360px;
    max-width: 90vw;
    border-radius: 18px;
    border: 1px solid rgba(30,64,175,0.7);
    background: radial-gradient(circle at top, rgba(15,23,42,0.98), rgba(15,23,42,1));
    padding: 18px 20px 16px;
    box-shadow: 0 26px 80px rgba(15,23,42,0.95);
  }
  .eqp-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .eqp-modal-title {
    font-size: 14px;
    font-weight: 600;
  }
  .eqp-modal-close {
    border: none;
    background: transparent;
    color: #9ca3af;
    cursor: pointer;
    font-size: 16px;
  }
  .eqp-modal-body {
    font-size: 12px;
    color: #e5e7eb;
  }
  .eqp-modal-body dl {
    margin: 0;
    display: grid;
    grid-template-columns: 110px 1fr;
    row-gap: 4px;
    column-gap: 8px;
  }
  .eqp-modal-body dt {
    color: var(--text-soft);
    text-align: right;
  }
  .eqp-modal-body dd {
    margin: 0;
  }
</style>
{% endblock %}

{% block content %}
  <div class="topology-layout">
    <p class="topology-intro">
      이 화면은 <b>계통 연결 정보를 트리 레이아웃</b>으로 시각화하는 <b>연결 정보</b> 탭입니다.<br />
      현재는 파일럿 데이터(JSON)를 사용하며, 이후 Modbus · WinCC OA · 기타 API에서 수집한 실제 설비 정보를 연동할 예정입니다.
    </p>

    <div class="topology-toolbar">
      <select id="topology-search-key" class="topology-search-select">
        <option value="id">EQP_NO</option>
        <option value="label">EQP_NAME</option>
      </select>
      <input
        id="topology-search-input"
        class="topology-search-input"
        type="text"
        placeholder="설비 번호 또는 이름을 입력하십시오. (*, ? 와일드카드 지원)"
      />
      <button id="topology-search-button" class="topology-search-button">
        검색
      </button>
    </div>

    <!-- 최근 검색 -->
    <div id="topology-recent" class="topology-recent"></div>

    <div class="topology-graph-shell" id="topology-shell">
      <div id="topology-graph" class="topology-graph">
        <svg id="topology-svg" class="topology-svg"></svg>
      </div>
    </div>

    <div class="topology-status-text" id="topology-status">
      검색할 설비를 선택하거나 이름을 입력하십시오.
    </div>

    <div class="topology-node-list" id="topology-node-list">
      <!-- 검색 성공 시에만 표가 렌더링됩니다. -->
    </div>
  </div>
  <!-- ▼ (추가) 마우스 오버 툴팁 -->
  <div id="eqp-tooltip" class="eqp-tooltip"></div>

  <!-- ▼ (추가) 노드 클릭 상세 모달 -->
  <div id="eqp-modal-backdrop" class="eqp-modal-backdrop">
    <div class="eqp-modal">
      <div class="eqp-modal-header">
        <div class="eqp-modal-title" id="eqp-modal-title">설비 상세</div>
        <button class="eqp-modal-close" id="eqp-modal-close">&times;</button>
      </div>
      <div class="eqp-modal-body">
        <dl>
          <dt>EQP_NO</dt><dd id="m-eqp-no"></dd>
          <dt>이름</dt><dd id="m-eqp-name"></dd>
          <dt>상태</dt><dd id="m-status"></dd>
          <dt>전압(V)</dt><dd id="m-voltage"></dd>
          <dt>전류(A)</dt><dd id="m-current"></dd>
          <dt>온도(°C)</dt><dd id="m-temperature"></dd>
          <dt>부하율(%)</dt><dd id="m-load-rate"></dd>
          <dt>알람 등급</dt><dd id="m-warning-level"></dd>
          <dt>업데이트</dt><dd id="m-updated-at"></dd>
        </dl>
      </div>
    </div>
  </div>  
{% endblock %}

{% block scripts %}
<script>
  (async function loadTopology() {
    const statusEl    = document.getElementById("topology-status");
    const graphShell  = document.getElementById("topology-shell");
    const svgEl       = document.getElementById("topology-svg");
    const listEl      = document.getElementById("topology-node-list");

    const searchKeyEl   = document.getElementById("topology-search-key");
    const searchInputEl = document.getElementById("topology-search-input");
    const searchBtnEl   = document.getElementById("topology-search-button");
    const recentEl      = document.getElementById("topology-recent");

        let eqpDataMap = {};  // eqp_no → 데이터

    const tooltip        = document.getElementById("eqp-tooltip");
    const modalBackdrop  = document.getElementById("eqp-modal-backdrop");
    const modalCloseBtn  = document.getElementById("eqp-modal-close");

    const mEqpNo        = document.getElementById("m-eqp-no");
    const mEqpName      = document.getElementById("m-eqp-name");
    const mStatus       = document.getElementById("m-status");
    const mVoltage      = document.getElementById("m-voltage");
    const mCurrent      = document.getElementById("m-current");
    const mTemperature  = document.getElementById("m-temperature");
    const mLoadRate     = document.getElementById("m-load-rate");
    const mWarnLevel    = document.getElementById("m-warning-level");
    const mUpdatedAt    = document.getElementById("m-updated-at");

    statusEl.textContent = "검색할 설비를 선택하거나 이름을 입력하십시오.";

    let allNodes = [];
    let allEdges = [];
    const nodeById    = {};
    const childrenMap = {};
    const parentMap   = {};

    // 드래그(팬) 상태
    let rootGroup = null;
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let startX = 0;
    let startY = 0;

    // 최근 검색 리스트 (메모리 캐시)
    let recentSearches = [];

    function applyPan() {
      if (rootGroup) {
        rootGroup.setAttribute("transform", `translate(${panX}, ${panY})`);
      }
    }

    // 마우스 드래그로 팬
    function attachPanHandlers() {
      graphShell.addEventListener("mousedown", (e) => {
        if (!rootGroup) return;
        if (e.button !== 0) return; // 좌클릭만
        isPanning = true;
        startX = e.clientX;
        startY = e.clientY;
        graphShell.style.cursor = "grabbing";
      });

      window.addEventListener("mousemove", (e) => {
        if (!isPanning || !rootGroup) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        panX += dx;
        panY += dy;
        startX = e.clientX;
        startY = e.clientY;
        applyPan();
      });

      window.addEventListener("mouseup", () => {
        if (!isPanning) return;
        isPanning = false;
        graphShell.style.cursor = "default";
      });

      graphShell.addEventListener("mouseleave", () => {
        if (!isPanning) return;
        isPanning = false;
        graphShell.style.cursor = "default";
      });
    }

    attachPanHandlers();

    //* ▼ (추가) /api/data에서 설비 계측 데이터 로드 */
    async function loadMeasurementData() {
      try {
        const res = await fetch("/api/equipment-data");
        if (!res.ok) return;
        const dj = await res.json();
        eqpDataMap = {};
        (dj.items || []).forEach(row => {
          // main.py에서 eqp_no / status / voltage / current / temperature / load_rate / warning_level / updated_at
          eqpDataMap[row.eqp_no] = row;
        });
      } catch (e) {
        console.error("계측 데이터 로드 실패", e);
      }
    }

    // 최근 검색: localStorage load/save
    function loadRecentSearches() {
      try {
        const raw = localStorage.getItem("egms_topology_recent");
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed;
      } catch {
        return [];
      }
    }

    function saveRecentSearches(list) {
      try {
        localStorage.setItem("egms_topology_recent", JSON.stringify(list));
      } catch (e) {
        console.warn("Failed to save recent searches", e);
      }
    }

    function addRecentSearch(key, query) {
      const trimmed = (query || "").trim();
      if (!trimmed) return;
      const id = key + "::" + trimmed.toLowerCase();

      // 중복 제거 후 맨 앞에 추가
      const filtered = recentSearches.filter(
        (item) => (item.key + "::" + item.query.toLowerCase()) !== id
      );
      filtered.unshift({ key, query: trimmed });

      // 최대 10개 유지
      recentSearches = filtered.slice(0, 10);
      saveRecentSearches(recentSearches);
      renderRecentSearches();
    }

    function renderRecentSearches() {
      if (!recentEl) return;
      if (!recentSearches.length) {
        recentEl.innerHTML = "";
        return;
      }

      let html = '<span class="topology-recent-label">최근 검색:</span>';
      recentSearches.forEach((item, idx) => {
        const keyLabel = item.key === "id" ? "EQP_NO" : "EQP_NAME";
        html += `
          <button 
            class="topology-recent-chip" 
            type="button"
            data-index="${idx}"
          >
            <span class="topology-recent-chip-key">${keyLabel}</span>
            <span class="topology-recent-chip-query">${item.query}</span>
          </button>
        `;
      });

      recentEl.innerHTML = html;

      // 클릭 이벤트 바인딩
      recentEl.querySelectorAll(".topology-recent-chip").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = parseInt(btn.getAttribute("data-index") || "0", 10);
          const item = recentSearches[idx];
          if (!item) return;
          searchKeyEl.value = item.key;
          searchInputEl.value = item.query;
          handleSearch(); // 재검색
        });
      });
    }

    // 와일드카드 매처 (*, ? 지원)
    function buildMatcher(raw) {
      const q = (raw || "").trim().toLowerCase();
      if (!q) {
        return () => false;
      }
      const hasWildcard = /[*?]/.test(q);
      if (!hasWildcard) {
        // 기본: 부분 문자열 포함
        return function (text) {
          return (text || "").toLowerCase().includes(q);
        };
      }
      // *, ? 를 정규식으로 변환
      let esc = q.replace(/[.+^${}()|[\]\\]/g, "\\$&");
      esc = esc.replace(/\*/g, ".*").replace(/\?/g, ".");
      const re = new RegExp("^" + esc + "$");
      return function (text) {
        return re.test((text || "").toLowerCase());
      };
    }

    try {
      const res = await fetch("/api/topology");
      if (!res.ok) {
        statusEl.textContent = "토폴로지 정보를 가져오지 못했습니다.";
        return;
      }

      const data = await res.json();
      allNodes = data.nodes || [];
      allEdges = data.edges || [];

      if (!allNodes.length) {
        statusEl.textContent = "표시할 노드가 없습니다.";
        return;
      }

      allNodes.forEach(n => {
        nodeById[n.id] = n;
        childrenMap[n.id] = [];
      });

      allEdges.forEach(e => {
        if (childrenMap[e.source]) {
          childrenMap[e.source].push(e.target);
          if (parentMap[e.target] == null) {
            parentMap[e.target] = e.source;
          }
        }
      });

      svgEl.innerHTML = "";
      listEl.innerHTML = "";
      statusEl.textContent = "검색할 설비를 선택하거나 이름을 입력하십시오.";
      // ▼ (추가) 계측 데이터도 함께 로드
      await loadMeasurementData();

      setInterval(async () => {
        await loadMeasurementData();   // eqpDataMap 최신화
        updateNodeStatusClasses();     // 노드 색깔 재적용
        }, 5000);

      // 최근 검색 로드
      recentSearches = loadRecentSearches();
      renderRecentSearches();
    } catch (err) {
      console.error(err);
      statusEl.textContent = "토폴로지 정보를 불러오는 중 오류가 발생했습니다.";
      return;
    }

    function clearGraphAndList() {
      svgEl.innerHTML = "";
      listEl.innerHTML = "";
      rootGroup = null;
      panX = 0;
      panY = 0;
    }

    // 여러 타겟에 대한 경로 하이라이트
    function highlightPaths(targetIds, nodePositionsPixel, focusId) {
      if (!rootGroup) return;
      if (!Array.isArray(targetIds) || !targetIds.length) return;

      // 기존 하이라이트 제거
      rootGroup
        .querySelectorAll(".topology-node--highlight")
        .forEach(el => el.classList.remove("topology-node--highlight"));
      rootGroup
        .querySelectorAll(".topology-edge--highlight")
        .forEach(el => el.classList.remove("topology-edge--highlight"));

      const allPathSet = new Set();

      targetIds.forEach((targetId) => {
        const path = [];
        let cur = targetId;
        const visited = new Set();
        while (cur && !visited.has(cur)) {
          visited.add(cur);
          path.push(cur);
          cur = parentMap[cur];
        }
        path.reverse();
        path.forEach((id) => allPathSet.add(id));

        // 간선 하이라이트
        for (let i = 0; i < path.length - 1; i++) {
          const src = path[i];
          const dst = path[i + 1];
          const line = rootGroup.querySelector(
            `.topology-edge[data-edge-source="${src}"][data-edge-target="${dst}"]`
          );
          if (line) line.classList.add("topology-edge--highlight");
        }
      });

      // 노드 하이라이트
      allPathSet.forEach((id) => {
        const g = rootGroup.querySelector(`.topology-node[data-node-id="${id}"]`);
        if (g) g.classList.add("topology-node--highlight");
      });

      // 포커스 노드 기준 중앙 정렬
      const focus = focusId || targetIds[0];
      const pos = nodePositionsPixel[focus];
      if (pos) {
        panX = graphShell.clientWidth / 2 - pos.x;
        panY = graphShell.clientHeight / 2 - pos.y;
        applyPan();
      }
    }

     /* ▼ (추가) 상태 → CSS 클래스 매핑 */
    function statusToClass(status) {
      const s = (status || "").toUpperCase();
      if (s === "NORMAL") return "status-normal";
      if (s === "WARN")   return "status-warn";
      if (s === "FAIL")   return "status-fail";
      return "status-unknown";
    }

     // ▼ (추가) 상태 클래스 목록 (리셋용)
    const STATUS_CLASSES = [
      "status-normal",
      "status-warn",
      "status-fail",
      "status-unknown",
    ];

    // ▼ (추가) eqpDataMap 기준으로 현재 그려진 노드들의 상태 색상을 다시 입히는 함수
    function updateNodeStatusClasses() {
      if (!rootGroup) return;

      const nodes = rootGroup.querySelectorAll(".topology-node");
      nodes.forEach((g) => {
        const id   = g.getAttribute("data-node-id");
        const meas = eqpDataMap[id] || {};

        // 기존 상태 클래스 제거
        STATUS_CLASSES.forEach((cls) => g.classList.remove(cls));

        // 새 상태 클래스 부여
        g.classList.add(statusToClass(meas.status));
      });
    }

    /* ▼ (추가) 툴팁/모달 표시 함수 */
    function showTooltip(evt, node, meas) {
      if (!tooltip) return;
      const m = meas || {};
      tooltip.innerHTML = `
        <div class="eqp-tooltip-title">${node.id}</div>
        <div class="eqp-tooltip-sub">${node.label || ""}</div>
        <div class="eqp-tooltip-row"><span>상태</span><span>${m.status ?? ""}</span></div>
        <div class="eqp-tooltip-row"><span>전압(V)</span><span>${m.voltage ?? ""}</span></div>
        <div class="eqp-tooltip-row"><span>전류(A)</span><span>${m.current ?? ""}</span></div>
        <div class="eqp-tooltip-row"><span>온도(°C)</span><span>${m.temperature ?? ""}</span></div>
        <div class="eqp-tooltip-row"><span>부하율(%)</span><span>${m.load_rate ?? ""}</span></div>
        <div class="eqp-tooltip-row"><span>알람 등급</span><span>${m.warning_level ?? ""}</span></div>
      `;
      tooltip.style.display = "block";
      tooltip.style.left = (evt.clientX + 16) + "px";
      tooltip.style.top  = (evt.clientY + 12) + "px";
    }

    function hideTooltip() {
      if (!tooltip) return;
      tooltip.style.display = "none";
    }

    function showModal(node, meas) {
      if (!modalBackdrop) return;
      const m = meas || {};
      mEqpNo.textContent       = node.id;
      mEqpName.textContent     = node.label || "";
      mStatus.textContent      = m.status ?? "";
      mVoltage.textContent     = m.voltage ?? "";
      mCurrent.textContent     = m.current ?? "";
      mTemperature.textContent = m.temperature ?? "";
      mLoadRate.textContent    = m.load_rate ?? "";
      mWarnLevel.textContent   = m.warning_level ?? "";
      mUpdatedAt.textContent   = m.updated_at ?? "";
      document.getElementById("eqp-modal-title").textContent = node.id + " 상세";
      modalBackdrop.style.display = "flex";
    }

   function attachNodeEvents(g, node) {
    g.addEventListener("mousemove", (e) => {
        const meas = eqpDataMap[node.id] || {};  // 최신 데이터 조회
        showTooltip(e, node, meas);
    });
    g.addEventListener("mouseleave", hideTooltip);
    g.addEventListener("click", () => {
     const meas = eqpDataMap[node.id] || {};
     showModal(node, meas);
    });
}

    // 모달 닫기 이벤트
    if (modalBackdrop && modalCloseBtn) {
      modalCloseBtn.onclick = () => { modalBackdrop.style.display = "none"; };
      modalBackdrop.onclick = (e) => {
        if (e.target === modalBackdrop) {
          modalBackdrop.style.display = "none";
        }
      };
    }

    // 여러 타겟 노드를 받아 "해당 계통들만" 그리기
    function renderTreeForTargets(targetNodes) {
      if (!targetNodes || !targetNodes.length) return;
      clearGraphAndList();

      // 1) 매칭된 노드들이 속한 루트(인입선)만 찾기
      const rootIdSet = new Set();

      targetNodes.forEach((n) => {
        let cur = n.id;
        const visited = new Set();
        while (cur && !visited.has(cur)) {
          visited.add(cur);
          const parent = parentMap[cur];
          if (!parent) { // 부모 없으면 루트
            rootIdSet.add(cur);
            break;
          }
          cur = parent;
        }
      });

      // 혹시라도 rootIdSet이 비면, fallback으로 전체 루트 사용
      if (!rootIdSet.size) {
        allNodes
          .filter(nd => !parentMap[nd.id])
          .forEach(nd => rootIdSet.add(nd.id));
      }

      const rootIds = Array.from(rootIdSet);

      // 2) 이 루트들 기준으로만 BFS → 관련된 계통만 groupSet에 포함
      const groupSet = new Set();
      const groupNodes = [];
      const queue = [...rootIds];

      while (queue.length) {
        const id = queue.shift();
        if (groupSet.has(id)) continue;
        groupSet.add(id);
        if (nodeById[id]) groupNodes.push(nodeById[id]);
        (childrenMap[id] || []).forEach(childId => {
          if (!groupSet.has(childId)) queue.push(childId);
        });
      }

      const groupEdges = allEdges.filter(
        e => groupSet.has(e.source) && groupSet.has(e.target)
      );

      // 3) 좌표 계산 (여러 루트 계통을 가로로 나란히)
      const xGap = 80;
      const yGap = 70;
      const positions = {};
      let leafIndex = 0;

      function assignPos(id, depth) {
        const childs = (childrenMap[id] || []).filter(c => groupSet.has(c));
        let x;

        if (!childs.length) {
          x = leafIndex * xGap;
          leafIndex += 1;
        } else {
          const xs = [];
          childs.forEach(childId => {
            assignPos(childId, depth + 1);
            xs.push(positions[childId].x);
          });
          const sum = xs.reduce((a, b) => a + b, 0);
          x = sum / xs.length;
        }

        positions[id] = { x, y: depth * yGap };
      }

      rootIds.forEach(rootId => assignPos(rootId, 0));

      const posList = Object.values(positions);
      const xs = posList.map(p => p.x);
      const ys = posList.map(p => p.y);
      const minX = Math.min(...xs);
      const maxX = Math.max(...xs);
      const minY = Math.min(...ys);
      const maxY = Math.max(...ys);

      const padding = 40;
      const width  = (maxX - minX) + padding * 2;
      const height = (maxY - minY) + padding * 2;

      svgEl.setAttribute("width", width);
      svgEl.setAttribute("height", height);
      svgEl.innerHTML = "";

      rootGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      rootGroup.setAttribute("id", "topology-root-group");
      svgEl.appendChild(rootGroup);

      function ax(x) { return x - minX + padding; }
      function ay(y) { return y - minY + padding; }

      const nodePositionsPixel = {};

      // 엣지
      groupEdges.forEach(e => {
        const sPos = positions[e.source];
        const tPos = positions[e.target];
        if (!sPos || !tPos) return;

        const x1 = ax(sPos.x);
        const y1 = ay(sPos.y);
        const x2 = ax(tPos.x);
        const y2 = ay(tPos.y);

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("class", "topology-edge-line topology-edge");
        line.setAttribute("data-edge-source", e.source);
        line.setAttribute("data-edge-target", e.target);
        rootGroup.appendChild(line);
      });

      // 노드
      const radius = 10;

      groupNodes.forEach(n => {
        const pos = positions[n.id];
        if (!pos) return;

        const cx = ax(pos.x);
        const cy = ay(pos.y);
        nodePositionsPixel[n.id] = { x: cx, y: cy };

        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.setAttribute("data-node-id", n.id);
        g.classList.add("topology-node");

        // ▼ (추가) 이 노드의 계측 데이터 조회
        const meas = eqpDataMap[n.id] || {};
        const cls  = statusToClass(meas.status);
        g.classList.add(cls);

        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", cx);
        circle.setAttribute("cy", cy);
        circle.setAttribute("r", radius);
        circle.setAttribute("class", "topology-node-circle");
        g.appendChild(circle);

        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        text.setAttribute("x", cx);
        text.setAttribute("y", cy + radius + 12);
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("class", "topology-node-label");
        text.textContent = n.label;
        g.appendChild(text);

        // ▼ (추가) hover/클릭 이벤트 연결
        attachNodeEvents(g, n);

        rootGroup.appendChild(g);
      });

      panX = 0;
      panY = 0;
      applyPan();

      // 표(해당 계통들만)
      const sortedGroupNodes = [...groupNodes].sort((a, b) =>
        (a.id || "").localeCompare(b.id || "")
      );

      let html = `
        <div style="margin-bottom:4px;">
          노드 ${sortedGroupNodes.length}개 · 엣지 ${groupEdges.length}개를 불러왔습니다.
        </div>
        <table class="topology-node-table">
          <thead>
            <tr>
              <th>EQP_NO</th>
              <th>EQP_NAME</th>
              <th>TYPE</th>
              <th>건물</th>
              <th>위치</th>
            </tr>
          </thead>
          <tbody>
      `;
      sortedGroupNodes.forEach(n => {
        html += `
          <tr>
            <td>${n.id}</td>
            <td>${n.label}</td>
            <td>${n.category || ""}</td>
            <td>${n.building || ""}</td>
            <td>${n.location || ""}</td>
          </tr>
        `;
      });
      html += "</tbody></table>";
      listEl.innerHTML = html;

      // 타겟 노드들 경로 하이라이트 + 중앙 정렬
      const targetIds = targetNodes.map((n) => n.id);
      highlightPaths(targetIds, nodePositionsPixel, targetNodes[0].id);
    }

    function handleSearch() {
      const key  = searchKeyEl.value;      // "id" | "label"
      const raw  = searchInputEl.value || "";
      const q    = raw.trim();

      if (!q) {
        clearGraphAndList();
        statusEl.textContent = "검색어가 입력되지 않았습니다.";
        return;
      }

      const matcher = buildMatcher(q);

      // 여러 대상 검색
      const matches = allNodes.filter((n) => {
        const targetText = key === "id" ? n.id : n.label;
        return matcher(targetText || "");
      });

      if (!matches.length) {
        clearGraphAndList();
        statusEl.textContent = `검색 결과가 없습니다: "${q}"`;
        return;
      }

      // 그래프 렌더링 (매칭된 설비가 포함된 계통만)
      renderTreeForTargets(matches);

      // 최근 검색 저장
      addRecentSearch(key, q);

      statusEl.textContent =
        `노드 ${allNodes.length}개 · 엣지 ${allEdges.length}개 중 "${q}"에 해당하는 설비 ${matches.length}개가 포함된 계통만 시각화했습니다.`;
    }

    searchBtnEl.addEventListener("click", handleSearch);
    searchInputEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") handleSearch();
    });
  })();
</script>
{% endblock %}
